# Архітектура TalentFluent

## Огляд

TalentFluent використовує Next.js App Router з правильною архітектурою для розділення серверних та клієнтських компонентів. Це забезпечує оптимальну SEO-оптимізацію та продуктивність.

## Принципи архітектури

### 1. Серверні компоненти (Server Components)
- **Призначення**: Рендеринг статичного контенту для SEO
- **Використання**: Головна сторінка, сторінки вакансій, кандидатів, компаній, "Про нас", "Контакти"
- **Переваги**: 
  - SEO-оптимізація
  - Швидкий рендеринг
  - Менше JavaScript на клієнті

### 2. Клієнтські компоненти (Client Components)
- **Призначення**: Інтерактивні елементи, контексти, стан
- **Використання**: Перемикач мови, фільтри, пошук, анімації
- **Маркування**: `'use client'` директива

### 3. Гібридний підхід
- Серверні компоненти рендерять статичний контент
- Клієнтські компоненти додають інтерактивність
- Дані передаються через props

## Структура файлів

```
app/
├── page.tsx                    # Головна сторінка (серверна)
├── jobs/
│   ├── page.tsx               # Сторінка вакансій (серверна)
│   └── jobs.css
├── candidates/
│   ├── page.tsx               # Сторінка кандидатів (серверна)
│   └── candidates.css
├── companies/
│   ├── page.tsx               # Сторінка компаній (серверна)
│   └── companies.css
├── about/
│   ├── page.tsx               # Сторінка "Про нас" (серверна)
│   └── about.css
├── contact/
│   ├── page.tsx               # Сторінка контактів (серверна)
│   └── contact.css
└── auth/
    ├── page.tsx               # Сторінка авторизації (клієнтська)
    └── callback/
        └── page.tsx           # Callback сторінка (клієнтська)

components/
├── ServerNavigation.tsx       # Серверна навігація
├── ServerFooter.tsx          # Серверний футер
├── ServerIcon.tsx            # Серверні іконки
├── ServerHomePage.tsx        # Серверна головна сторінка
├── ClientHomePage.tsx        # Клієнтська головна сторінка
├── ClientJobsPage.tsx        # Клієнтська сторінка вакансій
├── ClientCandidatesPage.tsx  # Клієнтська сторінка кандидатів
├── ClientCompaniesPage.tsx   # Клієнтська сторінка компаній
├── ClientOnly.tsx            # Обгортка для клієнтських компонентів
├── LanguageToggle.tsx        # Перемикач мови (клієнтський)
└── ServerComponents.css      # Стилі для серверних компонентів

lib/
└── server-data.ts            # Серверний шар даних

contexts/
├── AuthContext.tsx           # Контекст авторизації (клієнтський)
├── LanguageContext.tsx       # Контекст мови (клієнтський)
└── ThemeContext.tsx          # Контекст теми (клієнтський)
```

## Серверний шар даних

### `lib/server-data.ts`
- Містить функції для отримання даних на сервері
- Не використовує клієнтські контексти
- Повертає типізовані дані
- Містить мокові дані для демонстрації

### Приклад використання:
```typescript
// В серверному компоненті
const jobs = await getJobsData();
const candidates = await getCandidatesData();
const companies = await getCompaniesData();
```

## Серверні компоненти

### Принципи:
1. **Без `'use client'`** - рендеряться на сервері
2. **SEO-оптимізовані** - містять метадані
3. **Статичний контент** - не використовують стан або контексти
4. **Швидкі** - рендеряться один раз на сервері

### Приклад:
```typescript
// app/page.tsx
const HomePage: React.FC = async () => {
  const pageData = await getHomePageData();
  
  return (
    <>
      <ServerNavigation currentPath="/" />
      <ServerHomePage features={pageData.features} stats={pageData.stats} />
      <ClientHomePage />
      <ServerFooter />
    </>
  );
};
```

## Клієнтські компоненти

### Принципи:
1. **З `'use client'`** - рендеряться на клієнті
2. **Інтерактивні** - використовують стан, контексти, події
3. **Обгорнуті в `ClientOnly`** - для запобігання гідратаційних помилок
4. **Мінімальні** - тільки необхідна інтерактивність

### Приклад:
```typescript
// components/ClientHomePage.tsx
'use client';

export const ClientHomePage: React.FC = () => {
  return (
    <ClientOnly>
      <div className="language-toggle-container">
        <LanguageToggle />
      </div>
    </ClientOnly>
  );
};
```

## Передача даних

### Сервер → Клієнт:
- Дані передаються через props
- Серверні компоненти отримують дані через `await`
- Клієнтські компоненти отримують дані через props

### Приклад:
```typescript
// Серверний компонент
const pageData = await getHomePageData();
<ServerHomePage features={pageData.features} stats={pageData.stats} />

// Клієнтський компонент
interface ClientHomePageProps {
  features: Feature[];
  stats: Stat[];
}
```

## SEO-оптимізація

### Метадані:
- Кожна сторінка має `metadata` об'єкт
- OpenGraph та Twitter картки
- Ключові слова та описи

### Приклад:
```typescript
export const metadata: Metadata = {
  title: 'TalentFluent - AI-підсилена платформа для найму',
  description: 'Революція в наймі персоналу з використанням штучного інтелекту',
  keywords: 'AI, найм, HR, рекрутинг, таланти, автоматизація',
  openGraph: {
    title: 'TalentFluent - AI-підсилена платформа для найму',
    description: 'Революція в наймі персоналу з використанням штучного інтелекту',
    type: 'website',
  },
};
```

## Стилі

### Серверні компоненти:
- `ServerComponents.css` - загальні стилі
- Індивідуальні CSS файли для кожної сторінки
- Tailwind CSS для утилітарних стилів

### Клієнтські компоненти:
- Стилі в окремих CSS файлах
- CSS модулі для ізоляції стилів
- Tailwind CSS для швидкої розробки

## Переваги архітектури

1. **SEO-оптимізація**: Серверні компоненти рендеряться на сервері
2. **Продуктивність**: Менше JavaScript на клієнті
3. **Масштабованість**: Чітке розділення відповідальностей
4. **Підтримка**: Легко розуміти та модифікувати
5. **Гнучкість**: Можна додавати інтерактивність за потреби

## Рекомендації

1. **Використовуйте серверні компоненти** для статичного контенту
2. **Мінімізуйте клієнтські компоненти** - тільки для інтерактивності
3. **Передавайте дані через props** - не через контексти в серверних компонентах
4. **Обгортайте клієнтські компоненти** в `ClientOnly` для запобігання помилок
5. **Додавайте метадані** для кожної сторінки
6. **Використовуйте TypeScript** для типізації даних

## Майбутні покращення

1. **Кешування даних** - додати Redis або подібне
2. **ISR (Incremental Static Regeneration)** - для динамічних даних
3. **Edge Runtime** - для кращої продуктивності
4. **Streaming** - для великих списків даних
5. **Міжнародна локалізація** - серверна локалізація